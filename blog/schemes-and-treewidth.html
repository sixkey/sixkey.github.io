<html><head><title>Graph Schemes and Treewidth</title><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/public/bootstrap.min.css"><link rel="stylesheet" href="/public/index.css"></head><body><div id="root"><div id="content-root"><div id="left-wing"><img src="/public/graph.png" id="title-image"></div><div id="main-body"><div id="title-nav"><h1>Graph Schemes and Treewidth</h1><ul id="nav"><li><a href="/">xkucerak</a></li><li><a href="/uni">uni</a></li><li><a href="/blog">blog</a></li></ul></div><p>It is often the case that while studying a new piece of math, one starts to see the piece of math in everything. In today’s episode of hallucinations of abstract nonsense in computer science, we shall look at the connection between schemes–notion often used in algebraic geometry–and treewidth decomposition–a tool used for developing “efficient” algorithms for NP-complete problems on graphs.</p>
<h1 id="graphs-and-graph-homomorphisms">Graphs and graph homomorphisms</h1>
<p>Let us start by introducing graphs. Graph <span class="math inline">\(G\)</span> is a set of <em>vertices</em> <span class="math inline">\(V(G)\)</span> together with a set of <em>edges</em> <span class="math inline">\(E(G) \subseteq { V(G) \choose 2 }\)</span>. Thus, for the purpose of this post, we talk about simple undirected graphs (although it is not difficult to generalize the discussion to different graph classes; for the purposes of this post, it is fine to work with an intuitive definition of vertices with edges). An important notion (although quite underrated) for graphs is the notion of graph homomorphisms. Given a vertex map <span class="math inline">\(\varphi : V(G) \to V(H)\)</span>, we call the map a graph homomorphism if and only if for every edge <span class="math inline">\(uv\)</span> in <span class="math inline">\(E(G)\)</span>, we have that <span class="math inline">\(\varphi(u)\varphi(v)\)</span> is an edge of <span class="math inline">\(E(H)\)</span>. Thus, it is a vertex map where the adjacency is preserved in <em>one</em> direction, i.e., edges are mapped to edges, but there are no conditions for non-adjacent vertex pairs.</p>
<p>A nice example of the importance of graph homomorphisms are homomorphisms into cliques <span class="math inline">\(K_k\)</span> (graphs with <span class="math inline">\(k\)</span> vertices where every two are adjacent). A general set map <span class="math inline">\(V(G) \to A\)</span> can be viewed as a <span class="math inline">\(A\)</span>-coloring of the vertex set <span class="math inline">\(V(G)\)</span> as we are assigning to every vertex from <span class="math inline">\(V(G)\)</span> a color <span class="math inline">\(a \in A\)</span>. If we set <span class="math inline">\(A\)</span> to be a graph, the only constraint there is for a map <span class="math inline">\(\varphi: G \to K_k\)</span> to be a homomorphism is that the map does not map two neighboring vertices onto the same vertex; let <span class="math inline">\(uv\)</span> be two neighboring vertices, we need <span class="math inline">\(\varphi(u)\varphi(v)\)</span> to be an edge, which happens if and only if <span class="math inline">\(\varphi(u) \neq \varphi(v)\)</span>. Thus <span class="math inline">\(K_k\)</span>-homomorphism corresponds to <em>proper <span class="math inline">\(k\)</span>-colorings</em>, a notion studied quite extensively in graph theory.</p>
<p>Another surprising object, which can be described in terms of homomorphisms, is the notion of a vertex cover–a subset of graph vertices that cover all the edges. Given graph <span class="math inline">\(W\)</span> with two connected nodes, where one vertex <span class="math inline">\(w\)</span> has a loop (the vertex is connected to itself) and the other <span class="math inline">\(i\)</span> does not. Then, any homomorphism <span class="math inline">\(\varphi : G \to W\)</span> corresponds to a vertex cover of <span class="math inline">\(G\)</span>; consider any edge <span class="math inline">\(uv \in E(G)\)</span>, then <span class="math inline">\(\varphi(u)\varphi(v) \in E(W)\)</span> which means that at least one of the vertices <span class="math inline">\(\varphi(u), \varphi(v)\)</span> needs to be <span class="math inline">\(w \in E(W)\)</span> thus <span class="math inline">\(\varphi^{-1}(w)\)</span> is a vertex cover. It can be easily checked that any vertex cover indeed corresponds to an <span class="math inline">\(W\)</span>-homomorphism.</p>
<p>Given such a homomorphism notion, one may wonder:</p>
<ul>
<li>Given a graph <span class="math inline">\(G\)</span>, how hard is to check that there exists a homomorphism <span class="math inline">\(\varphi: G \to K_3\)</span> or <span class="math inline">\(\varphi: G \to H\)</span> for general <span class="math inline">\(H\)</span>?</li>
<li>Given an assignment of some cost to some <span class="math inline">\(H\)</span>-homomorphisms, how hard is it to find an optimal homomorphism?</li>
</ul>
<p>Both problems prove to be hard, e.g., the first problem corresponds to 3-COL and thus to 3-SAT in terms of computational difficulty–meaning it is NP-complete. Is homomorphism existence checking always NP-complete? A complete classification of homomorphism finding difficulty is due to the Hell-Nešetřil theorem, which states that the <span class="math inline">\(H\)</span>-coloring problem (finding an <span class="math inline">\(H\)</span>-homomorphism) is in P if and only if the graph is bipartite, otherwise it is NP-complete.</p>
<h1 id="graph-topology">Graph Topology</h1>
<p>In this section, we will try to describe canonical subparts of a given graph <span class="math inline">\(G\)</span> in terms of <em>topology</em>. A general topology <span class="math inline">\(T\)</span> on some set <span class="math inline">\(X\)</span> is a family of sets that is closed under finite intersections, under arbitrary unions, contains the empty set, and contains the whole set <span class="math inline">\(X\)</span>. One should think of topology as a set with canonical regions or segments. We call elements of <span class="math inline">\(T\)</span> <em>open sets</em> over <span class="math inline">\(X\)</span>. A popular example of a topology is the real line, with open sets being sets that can be created from arbitrary unions of open intervals. Another example (which is just a generalization of the real line) is a Euclidian space <span class="math inline">\(\mathbb{R}^{n}\)</span> together with sets which are arbitrary unions of some <span class="math inline">\(\delta\)</span>-balls, i.e., sets of points, which are in the euclidian distance at most <span class="math inline">\(\delta\)</span> far from the set’s center.</p>
<p>Let us define a simple topology on graphs by taking the underlying set <span class="math inline">\(X\)</span> to be the disjoint union <span class="math inline">\(V(G) \sqcup E(G)\)</span> and letting a subset <span class="math inline">\(V&#39; \sqcup E&#39;\)</span> be open if and only if <span class="math inline">\(E&#39;\)</span> contains only the vertices from <span class="math inline">\(V&#39;\)</span> (thus the pair <span class="math inline">\((V&#39;,E&#39;)\)</span> corresponds to a subgraph <span class="math inline">\(G&#39;\)</span> of the original graph <span class="math inline">\(G\)</span>). Does this choice define a topology? Could one use induced subgraphs instead?</p>
<h1 id="presheaves">Presheaves</h1>
<p>For those who know category theory, a set presheaf is just a contravariant functor from some category <span class="math inline">\(C\)</span> into category <strong>Set</strong>. In this case, the category <span class="math inline">\(C\)</span> will be the category of open sets <span class="math inline">\(O_X\)</span>, where the arrows are the inclusions (thus, it is just a poset category).</p>
<p>For those who do not want to know category theory, a set presheaf <span class="math inline">\(F\)</span> will be a pair of maps. First, a map from our topological space mapping each open set <span class="math inline">\(U \subseteq X\)</span> to <em>some</em> set <span class="math inline">\(F(U)\)</span> and a map of inclusions into restrictions, i.e., for every <span class="math inline">\(U \supseteq V\)</span> we will pick a function <span class="math inline">\(\rho_{U,V}\)</span> which serves as a restriction map of elements from <span class="math inline">\(F(U)\)</span> to some elements of <span class="math inline">\(F(V)\)</span>. The elements of <span class="math inline">\(F(U)\)</span> are often called <em>sections</em> at <span class="math inline">\(U\)</span>. Restriction maps thus send for <span class="math inline">\(U \supseteq V\)</span> a section at <span class="math inline">\(U\)</span> to some section at <span class="math inline">\(V\)</span>. The presheaf needs to satisfy the following rules: <span class="math inline">\(\rho_{U, U}\)</span> is just identity on <span class="math inline">\(F(U)\)</span>, and restrictions compose, i.e., for <span class="math inline">\(U \supseteq V \supseteq W\)</span>, we have that <span class="math inline">\(\rho_{V, W} \circ \rho_{U, V} = \rho_{U, W}\)</span>. It is important to note that there is no semantic requirement for the sets <span class="math inline">\(F(U)\)</span>, i.e., the sets <span class="math inline">\(F(U)\)</span> can be whatever you like, as long as you can find meaningful restriction maps.</p>
<p>That being said, there are some canonical examples, such as the set presheaf, which maps each open set <span class="math inline">\(U\)</span> to the set of continuous functions from <span class="math inline">\(U\)</span> to <span class="math inline">\(\mathbb{R}\)</span>, where <span class="math inline">\(\rho_{U,V}\)</span> is a map realizing the appropriate function restriction, i.e., map which sends the continuous function <span class="math inline">\(f: U \to \mathbb{R}\)</span> to <span class="math inline">\(\left.{f}\right|_{V} : V \to \mathbb{R}\)</span> which is continuous.</p>
<p>Given a topology of Euclidian space, one can take a set presheaf which maps each open set <span class="math inline">\(U\)</span> to the set of differentiable functions on <span class="math inline">\(U\)</span>, where <span class="math inline">\(\rho_{U,V}\)</span> are again just map restrictions.</p>
<p>The set presheaf we shall investigate is the <span class="math inline">\(H\)</span>-homomorphism presheaf <span class="math inline">\(\mathcal{H}\)</span> that maps each open set <span class="math inline">\(G&#39;\)</span> of a graph topology into a set of homomorphisms from <span class="math inline">\(G&#39;\)</span> into <span class="math inline">\(H\)</span>, i.e., the map <span class="math inline">\(G&#39; \mapsto \text{Hom}(G&#39;, H)\)</span>. As the <span class="math inline">\(\rho_{U, V}\)</span>, we once again take the restriction maps.</p>
<h1 id="sheaves">Sheaves</h1>
<p>If I had to pick one piece of important abstractions from the post, I would say it is that of sheaves. A set sheaf is a set presheaf that satisfies two important axioms for every open cover <span class="math inline">\((U_i)_{i \in I}\)</span> of any open set <span class="math inline">\(U\)</span>:</p>
<ol type="1">
<li><p><strong>Gluing:</strong> Let <span class="math inline">\((f_i \in F(U_i))_{i\in I}\)</span> be a collection of sections that agree on the intersections, i.e., for all <span class="math inline">\(i, j\)</span> from <span class="math inline">\(I\)</span>, we have that <span class="math inline">\(\left.{f_i}\right|_{U_i \cap U_j} = \left.{f_j}\right|_{U_i \cap U_j}\)</span>. Then, there exists a section <span class="math inline">\(f\)</span> from <span class="math inline">\(F(U)\)</span> such that it restricts to the sections, i.e., for all <span class="math inline">\(i\)</span> from <span class="math inline">\(I\)</span>, we have <span class="math inline">\(\left.{f}\right|_{U_i} = f_i\)</span>.</p></li>
<li><p><strong>Unique:</strong> Given sections <span class="math inline">\(f, g \in F(U)\)</span>, we have that if they agree on all sets of the open cover, then it is the same section, i.e., if for all <span class="math inline">\(i\)</span> from <span class="math inline">\(I\)</span>, we have that if <span class="math inline">\(\left.{f}\right|_{U_i} = \left.{g}\right|_{U_i}\)</span>, then <span class="math inline">\(f = g\)</span>.</p></li>
</ol>
<p>Thus, sheaves capture the notion of unique gluing of sections over a space. Take the example of the presheaf of continuous functions (a presheaf which to each open set <span class="math inline">\(U\)</span> assigns the set of continuous functions to some topological space, e.g., <span class="math inline">\(\mathbb{R}\)</span>). Then, such presheaf is a sheaf. Uniqueness essentially comes down to functional extensionality (as <span class="math inline">\((U_i)_{i \in I}\)</span> is a cover, <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> agree on all the points and so are the same function), and an elementary result from topology tells us that continuous functions can be glued to continuous functions.</p>
<p>We will reserve actual “proving” (read proof sketching) for sheaf that will be of importance to us, the <span class="math inline">\(H\)</span>-homomorphism sheaf <span class="math inline">\(\mathcal{H}\)</span>–a sheaf, which to every subgraph <span class="math inline">\(G&#39;\)</span> of <span class="math inline">\(G\)</span> assigns the set of homomorphisms from <span class="math inline">\(G&#39;\)</span> to <span class="math inline">\(H\)</span>. The proof is very easy and gives intuition behind the two axioms.</p>
<p>First, let us show that the uniqueness axiom holds. Take an open cover <span class="math inline">\((G_i)_{i \in I}\)</span> of our graph <span class="math inline">\(G\)</span> and two homomorphisms <span class="math inline">\(\varphi, \psi: G \to H\)</span>. They are equal if and only if they assign to every vertex from <span class="math inline">\(V(G)\)</span> the same vertex in <span class="math inline">\(V(H)\)</span>. But every vertex <span class="math inline">\(v\)</span> belongs to some <span class="math inline">\(G_i\)</span> (as they cover <span class="math inline">\(G\)</span>). Thus as <span class="math inline">\(\left.{\varphi}\right|_{G_i} = \left.{\psi}\right|_{G_i}\)</span> we have <span class="math inline">\(\varphi(v) = \psi(v)\)</span> and we are done.</p>
<p>Second, we need to show the gluing. So let <span class="math inline">\((G_i)_{i \in I}\)</span> be an open cover of <span class="math inline">\(G\)</span> and let <span class="math inline">\((\varphi_i)_{i \in I}\)</span> be <span class="math inline">\(H\)</span>-homomorphisms that agree on the intersections. Let <span class="math inline">\(\varphi\)</span> be the function that is created by gluing the underlying functions of all <span class="math inline">\(\varphi_i\)</span>. We need to check that this is a homomorphism. Let <span class="math inline">\(uv \in E(G)\)</span> be an edge. As <span class="math inline">\((G_i)_{i \in I}\)</span> is an open cover, there is a graph <span class="math inline">\(G_i\)</span> which contains the edge and both vertices of the edge. Thus <span class="math inline">\(\varphi(uv) = \left.{\varphi}\right|_{G_i}(uv) = \varphi_i(uv) \in E(H)\)</span> as <span class="math inline">\(\varphi_i\)</span> is a homomorphism. It is now clear why the topology is defined as is because we need the cover to contain a single open set that contains both the edge and the vertices.</p>
<p>This means our <span class="math inline">\(H\)</span>-homomorphism presheaf is indeed a sheaf.</p>
<h1 id="graph-schemes">Graph schemes</h1>
<p>The final definition from the geometry world is that of a <em>scheme</em>. The definition is very simple. A scheme is a set <span class="math inline">\(X\)</span> together with a topology <span class="math inline">\(T\)</span> and a sheaf from T.</p>
<p>Let me note that schemes usually have a richer sheaf than just a set sheaf, e.g., a group or (canonically) commutative ring sheaf. These sheaves require the sets of sections <span class="math inline">\(F(U)\)</span> to be endowed with the structure of a group or a ring. In this post, we require only a set sheaf. For those who want their schemes to contain only ring sheaves, you can safely view this post as one discussing graph sheaves instead of graph schemes.</p>
<p>As an example, one can again take a topological space together with a sheaf of real-valued continuous functions, a differentiable manifold, or a graph with graph topology and a <span class="math inline">\(H\)</span>-homomorphism sheaf, which we will call a <em>graph scheme</em>.</p>
<p>Given a scheme <span class="math inline">\(\mathcal{S}\)</span> on space <span class="math inline">\(X\)</span> it is natural to ask whether the set of sections <span class="math inline">\(F(X)\)</span> is nonempty, how many elements does such set have, or given a cost function <span class="math inline">\(f: \bigcup_{U \in \mathcal{O}_X}F(U) \to \mathbb{R}\)</span> what section in <span class="math inline">\(F(X)\)</span> minimizes/maximizes the function.</p>
<p>As an example, given a graph scheme with triangle-homomorphism sheaf, the existence of section in <span class="math inline">\(F(G)\)</span> corresponds to a 3-coloring of the graph <span class="math inline">\(G\)</span>; given a graph scheme with W-homomorphism sheaf and a function <span class="math inline">\(f\)</span> which assign to a <span class="math inline">\(W\)</span>-homomorphism the number of vertices assigned to the vertex <span class="math inline">\(W\)</span>, optimization of <span class="math inline">\(f\)</span> over <span class="math inline">\(F(G)\)</span> corresponds to finding the minimum vertex cover. Thus, scheme problems over graph schemes are natural computational problems. Does the scheme/sheaf formulation bring us any insight? To answer, we need to discuss the following concept.</p>
<h1 id="treewidth-and-tree-decomposition">Treewidth and tree decomposition</h1>
<p>Let us first define a tree decomposition. Given a graph <span class="math inline">\(G\)</span>, we say that an open cover by <em>bags</em> <span class="math inline">\((B_t)_{t \in T}\)</span> indexed by vertices in a tree <span class="math inline">\(T\)</span> is a tree decomposition if and only if for every <span class="math inline">\(v \in G\)</span> we have that <span class="math inline">\(\{t \in T | v \in B_t \}\)</span> is a connected subtree in <span class="math inline">\(T\)</span>.</p>
<p>The main point is that the bags (a) interact in a tree-like fashion–which allows us to do dynamic programming over the decomposition (b) any interaction over a vertex is localized into a connected part of <span class="math inline">\(T\)</span>, and (c) every edge <span class="math inline">\(uv\)</span> is in some bag <span class="math inline">\(B_t\)</span> (as open cover needs to cover not only vertices but also edges).</p>
<p>The treewidth of a graph <span class="math inline">\(G\)</span> then becomes the minimum width of any tree-decomposition, where the width of tree-decomposition is the maximum size of the bag a <span class="math inline">\(B_t\)</span> minus one (something something historical mistakes something something).</p>
<p><em>Motivation behind the historical mistake:</em> Any graph <span class="math inline">\(G\)</span> which is a tree, has treewidth 1.</p>
<p><em>Example:</em> Any cycle <span class="math inline">\(C\)</span> has treewidth 2.</p>
<p><em>Example:</em> Any <span class="math inline">\(n\)</span> by <span class="math inline">\(n\)</span> grid has treewidth <span class="math inline">\(n\)</span>.</p>
<p>The motivation behind this post is not to bring any insight into the structural properties of treewidth–even though they are interesting. It is enough you understand the definition. Moreover, treatment using sheaves clearly shows motivation behind every part of the definition–thus, it should lead to <em>some</em> intuition.</p>
<h1 id="decision-problems">Decision problems</h1>
<p>Let us first look at the problem of deciding if the set of sections over <span class="math inline">\(G\)</span> is nonempty. Let us assume that there exists a brute-force algorithm with complexity <span class="math inline">\(f(n)\)</span> which returns all sections for <span class="math inline">\(G&#39; \subseteq G\)</span> with <span class="math inline">\(n\)</span> vertices. Such brute-force algorithms are usually easy to get but are, of course, not reasonable for large <span class="math inline">\(n\)</span>. That being said, we can still use them if we limit the use to <em>small</em> graphs, i.e., small open sets of our target <span class="math inline">\(G\)</span>. We can then use the properties of the sheaf, namely the gluing property, to construct a section over the whole graph. For this, we thus need two things:</p>
<ol type="1">
<li>A nice open cover of <span class="math inline">\(G\)</span> with small open sets</li>
<li>that are organized in a way that allows us to do systematic and cheap gluing.</li>
</ol>
<p>But that is precisely the motivation behind the tree-decomposition of a graph. The first step of the algorithm is thus to obtain a nice tree-decomposition. Let us assume that there exists an algorithm that gives us a rooted tree-decomposition of a graph that achieves the actual treewidth of the graph. Moreover, let us assume that the indexing tree of the decomposition is binary, i.e., every node has either two or zero children (one can show that such decomposition is always achievable). A tree-decomposition can thus be described by the following type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Graph</span> v <span class="ot">=</span> <span class="dt">Graph</span> {<span class="ot"> vertices ::</span> <span class="dt">Set</span> v,<span class="ot"> edges ::</span> <span class="dt">Set</span> ( <span class="dt">Pair</span> v ) }</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TreeDecomposition</span> a <span class="ot">=</span> <span class="dt">Leaf</span> ( <span class="dt">Graph</span> v )</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                         <span class="op">|</span> <span class="dt">Node</span> ( <span class="dt">Graph</span> v ) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                                ( <span class="dt">TreeDecomposition</span> v ) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                                ( <span class="dt">TreeDecomposition</span> v )</span></code></pre></div>
<p>Before discussing the algorithm, let us briefly look at the types of the mentioned concepts. Let us start with the geometry.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Section</span> u s <span class="ot">=</span> <span class="dt">Section</span> {<span class="ot"> open ::</span> u,<span class="ot"> section ::</span> s } <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sheaf</span> u s <span class="ot">=</span> <span class="dt">Sheaf</span> {<span class="ot"> smap     ::</span> u <span class="ot">-&gt;</span> <span class="dt">Set</span> ( <span class="dt">Section</span> u s ),</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">                         restrict ::</span> u <span class="ot">-&gt;</span> <span class="dt">Section</span> u s <span class="ot">-&gt;</span> <span class="dt">Section</span> u s,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">                         glue     ::</span> <span class="dt">Section</span> u s <span class="ot">-&gt;</span> <span class="dt">Section</span> u s <span class="ot">-&gt;</span> <span class="dt">Section</span> u s }</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Scheme</span> u s <span class="ot">=</span> <span class="dt">Scheme</span> u ( <span class="dt">Sheaf</span> u s )</span></code></pre></div>
<p>The <code>Sheaf</code> type (the most important of the three) contains two type parameters:</p>
<blockquote>
<p>u: the type of the open sets (you can safely substitute <code>Graph v</code>)</p>
</blockquote>
<blockquote>
<p>s: the type parameter of the section (this can be homomorphisms, generic functions, etc.)</p>
</blockquote>
<p>Value of <code>Sheaf</code> contains the brute-force algorithm <code>smap</code>, which to each open set assigns the set of sections (the object mapping part of the sheaf), a function <code>restrict</code> which produces restrictions of sections (the inclusion mapping of the sheaf), and finally the gluing function <code>glue</code>. Let us get to the algorithm itself.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>exists ( <span class="dt">Scheme</span> graph sheaf ) <span class="ot">=</span> nonempty ( existsGo ( treeDecomp graph ) )</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    existsGo ( <span class="dt">Leaf</span> b )     <span class="ot">=</span> smap sheaf b</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    existsGo ( <span class="dt">Node</span> b l r ) <span class="ot">=</span> </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> lSecs <span class="ot">=</span> existsGo l </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>          rSecs <span class="ot">=</span> existsGo r</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="fu">filter</span> ( \s <span class="ot">-&gt;</span> compWith lSecs s <span class="op">&amp;&amp;</span> compWith rSecs s ) ( smap sheaf b )</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    compWith sections s <span class="ot">=</span> <span class="fu">any</span> ( agree s ) sections</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    agree a b <span class="ot">=</span> <span class="kw">let</span> common <span class="ot">=</span> intersection ( open a ) ( open b ) </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> restrict sheaf common a <span class="op">==</span> restrict sheaf common b   </span></code></pre></div>
<p>Function <code>existsGo</code> assigns to each bag in the tree decomposition sections that can be extended into a section for the union of the bags in the subtree (as we will shortly show). Function <code>compWith</code> checks if any section from the set <code>sections</code> agrees with <code>s</code> on intersection. Finally, <code>exists</code> just checks that <code>existsGo</code> is nonempty for the root bag.</p>
<p>One can show using induction over the tree-decomposition that the following invariant holds. If there is a section <span class="math inline">\(s \in F(B_t)\)</span> which is in the set <span class="math inline">\(\text{existsGo}(B_t)\)</span>, then there exists a section <span class="math inline">\(\hat{s} \in F(\hat{B_t})\)</span>, where <span class="math inline">\(\hat{B_t}\)</span> denotes the union of all bags under <span class="math inline">\(t\)</span>. For leaves, the statement is trivial. For interval nodes, section is in <span class="math inline">\(\text{existsGo}(B_t)\)</span> if and only if there exists a section <span class="math inline">\(s_l \in \text{existsGo}(B_l)\)</span> and a section <span class="math inline">\(s_r \in \text{existsGo}(B_r)\)</span> such that <span class="math inline">\(s\)</span> agrees with <span class="math inline">\(s_l\)</span> on their intersection and <span class="math inline">\(s\)</span> agrees with <span class="math inline">\(s_r\)</span> on their intersection. Due to the fact that <span class="math inline">\((B_t)_{t \in T}\)</span> is a tree-decomposition, we know that every vertex in <span class="math inline">\(\hat{B_l} \cap B_t\)</span> is contained in <span class="math inline">\(B_l \cap B_t\)</span> (bags which contain a vertex need to be a connected subtree, thus any vertex shared by a bag and its indirect descendant is also shared by the bag and its direct child, i.e., vertex cannot skip a generation). Thus, the section <span class="math inline">\(\hat{s_l} \in F(\hat{B_l})\)</span> from induction hypothesis and <span class="math inline">\(s\)</span> agree on their intersection. Similarly, we get <span class="math inline">\(\hat{s_r} \in F(\hat{B_r})\)</span>. Finally, any vertex shared by <span class="math inline">\(\hat{B_l}\)</span> and <span class="math inline">\(\hat{B_r}\)</span> needs to be in the <span class="math inline">\(B_t\)</span> (again due to connection property of the tree-decomposition) and thus <span class="math inline">\(\hat{s_l}\)</span> and <span class="math inline">\(\hat{s_r}\)</span> agree on their intersection. We can thus glue the three sections <span class="math inline">\(s\)</span>, <span class="math inline">\(\hat{s_l}\)</span>, and <span class="math inline">\(\hat{s_r}\)</span> to obtain the desired section <span class="math inline">\(\hat{s} \in F(\hat{B_t})\)</span>. As tree-decomposition is an open-cover of <span class="math inline">\(G\)</span>, we have that for the root bag <span class="math inline">\(B_r\)</span> it holds that <span class="math inline">\(\hat{B_r} = G\)</span>. Thus a section <span class="math inline">\(s_r \in \text{existsGo}(B_r)\)</span> can be extended to a section over <span class="math inline">\(G\)</span>.</p>
<p>Let us show by induction the converse, that is, if there is a section <span class="math inline">\(\hat{s} \in F(\hat{B_t})\)</span>, then there is a section <span class="math inline">\(s \in \text{existsGo}(B_t)\)</span> such that <span class="math inline">\(\left.{\hat{s}}\right|_{B_t} = s\)</span>. For leaves, the statement is again trivial. For internal nodes assume <span class="math inline">\(s \in F(\hat{B_t})\)</span>. We have that there are restrictions <span class="math inline">\(\hat{s_l} \in F(\hat{B_l})\)</span> and <span class="math inline">\(\hat{s_r} \in F(\hat{B_r})\)</span>. From induction hypothesis there are further restrictions <span class="math inline">\(s_l \in \text{existsGo}(B_l)\)</span> and <span class="math inline">\(s_r \in \text{existsGo}(B_r)\)</span>. But restriction of <span class="math inline">\(s\)</span> to <span class="math inline">\(B_t\)</span> agrees with <span class="math inline">\(s_l\)</span> and <span class="math inline">\(s_r\)</span> on intersections, thus <span class="math inline">\(\left.{s}\right|_{B_t} \in \text{existsGo}(B_t)\)</span>.</p>
<p>Inspecting the complexity of the algorithm reveals that we do <span class="math inline">\(O(f(b)^2)\)</span> work for each bag, where <span class="math inline">\(b\)</span> is the maximum size of all bags (the current bag, the bag of the left child, and the bag of the right child) and <span class="math inline">\(f\)</span> is the complexity of <code>smap</code>. As each bag is handled exactly once, the overall complexity is thus <span class="math inline">\(f&#39;(\text{tw(G)})O(|T|)\)</span>, where <span class="math inline">\(\text{tw}(G)\)</span> is the treewidth of the graph, <span class="math inline">\(f&#39;\)</span> is some function which depends on <span class="math inline">\(f\)</span>, and <span class="math inline">\(|T|\)</span> is the size of the decomposition. Algorithms with such complexity are called FPT (fixed-parameter tractable) as fixing the maximum treewidth of the input graphs turns <span class="math inline">\(f&#39;(\text{tw(G)})\)</span> into a constant which in turn leads to a polynomial complexity.</p>
<p>Finally, we have the following two theorems, which show that we can <em>actually</em> find a reasonable tree-decomposition of a graph. One should note that determining the exact treewidth of a graph is NP-hard.</p>
<p><strong>Theorem.</strong> [BDDFLP] There exists an algorithm which for graph <span class="math inline">\(G\)</span> with <span class="math inline">\(n\)</span> vertices of treewidth <span class="math inline">\(k\)</span> returns a tree-decomposition of width 5k + 4 in time <span class="math inline">\(2 O(k)n\)</span>.</p>
<p>There are different algorithms achieving different treewidth approximations with different complexities. The above theorem still leads to an FPT algorithm, even though we do not get the precise treewidth.</p>
<p>Note that we did not, in fact, use the <code>glue</code> operation provided by the sheaf. Such operation is needed when we want to <em>construct</em> a witness to the existence. We can do so by adding the <span class="math inline">\(\hat{s}\)</span> information to all sections <span class="math inline">\(s\)</span> in the induction step.</p>
<p>Note that the proof uses all the properties of the tree-decomposition. We need the cover property (which includes both edges and vertices) so that the extension of the root bag is the graph itself, tree connectedness so that we can conclude that if sections agree on their intersection, the extended sections also agree on their intersection, and small bag size to bound the complexity of brute-force calls.</p>
<p>The above algorithm can be used for a multitude of problems where the “only” requirement is to implement the functions needed for the sheaf object. Due to the fact that <span class="math inline">\(H\)</span>-homomorphisms are graph sheaves and a lot of problems can be rephrased in terms of <span class="math inline">\(H\)</span>-homomorphisms for some <span class="math inline">\(H\)</span>, the above algorithm is the core of many treewidth-parametrized algorithms.</p>
<h1 id="optimization-problems">Optimization problems</h1>
<p>One day.</p></div></div><footer><div class="footer-text"><div>made with ❤️ in Brno and Leipzig</div><div><a href="https://github.com/sixkey/yabg">github</a></div></div></footer></div></body></html>